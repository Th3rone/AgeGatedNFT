<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Age Gated NFT with Zama FHEVM</title>
    <style>
        :root {
            --color-bg: #0f1419;
            --color-surface: #1a1f26;
            --color-border: #2d3748;
            --color-text: #e2e8f0;
            --color-text-secondary: #a0aec0;
            --color-accent: #48bb78;
            --color-accent-hover: #38a169;
            --color-error: #f56565;
            --color-warning: #ed8936;
            --muted: #718096;
            --spacing: 16px;
        }

        * {
            box-sizing: border-box;
        }

        html, body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: var(--color-bg);
            color: var(--color-text);
            line-height: 1.6;
        }

        body {
            padding: var(--spacing);
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 40px;
            padding-bottom: 24px;
            border-bottom: 1px solid var(--color-border);
        }

        header > div {
            flex: 1;
            text-align: center;
        }

        h1 {
            margin: 0 0 8px 0;
            font-size: 28px;
            font-weight: 600;
        }

        .subtitle {
            color: var(--color-text-secondary);
            font-size: 14px;
            margin: 0;
        }

            
        .grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 24px;
            margin-bottom: 40px;
        }

        @media (min-width: 768px) {
            .grid {
                grid-template-columns: 1fr 1fr;
            }
            
            .console-section {
                grid-column: 1 / -1;
            }
        }

        .card {
            background-color: var(--color-surface);
            border: 1px solid var(--color-border);
            border-radius: 8px;
            padding: 24px;
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .card h3 {
            margin: 0;
            font-size: 18px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .card-number {
            background: var(--color-accent);
            color: var(--color-bg);
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
        }

        .description {
            color: var(--muted);
            font-size: 13px;
            margin: 0;
        }

        label {
            display: block;
            font-size: 13px;
            font-weight: 500;
            color: var(--color-text);
            margin-bottom: 6px;
        }

        input[type="number"],
        input[type="text"] {
            width: 100%;
            padding: 10px 12px;
            background-color: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--color-border);
            border-radius: 6px;
            color: var(--color-text);
            font-size: 14px;
            transition: border-color 0.2s;
        }

        input[type="number"]:focus,
        input[type="text"]:focus {
            outline: none;
            border-color: var(--color-accent);
        }

        input::placeholder {
            color: var(--muted);
        }

        .row {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }

        .btn {
            padding: 10px 16px;
            background-color: var(--color-accent);
            color: var(--color-bg);
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s;
            white-space: nowrap;
        }

        .btn:hover {
            background-color: var(--color-accent-hover);
        }

        .btn:active {
            transform: scale(0.98);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn.secondary {
            background-color: rgba(72, 187, 120, 0.15);
            color: var(--color-accent);
            border: 1px solid var(--color-accent);
        }

        .btn.secondary:hover {
            background-color: rgba(72, 187, 120, 0.25);
        }

        .status {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
        }

        .status.success {
            background-color: rgba(72, 187, 120, 0.15);
            color: var(--color-accent);
            border: 1px solid var(--color-accent);
        }

        .status.error {
            background-color: rgba(245, 101, 101, 0.15);
            color: var(--color-error);
            border: 1px solid var(--color-error);
        }

        .status.loading {
            background-color: rgba(237, 137, 54, 0.15);
            color: var(--color-warning);
            border: 1px solid var(--color-warning);
        }

        .result {
            background-color: rgba(72, 187, 120, 0.1);
            border: 1px solid var(--color-accent);
            border-radius: 6px;
            padding: 12px;
            font-size: 13px;
        }

        .result-label {
            font-weight: 600;
            color: var(--color-accent);
            margin-bottom: 4px;
        }

        .result-value {
            color: var(--color-text-secondary);
            word-break: break-all;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }

        pre {
            background-color: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--color-border);
            border-radius: 6px;
            padding: 12px;
            overflow-x: auto;
            font-size: 12px;
            color: var(--color-text-secondary);
            margin: 0;
            font-family: 'Courier New', monospace;
            line-height: 1.4;
            max-height: 200px;
            overflow-y: auto;
        }

        .console-section {
            background-color: var(--color-surface);
            border: 1px solid var(--color-border);
            border-radius: 8px;
            padding: 24px;
        }

        .console-section h3 {
            margin: 0 0 8px 0;
            font-size: 18px;
            font-weight: 600;
        }

        #devLog {
            background-color: rgba(0, 0, 0, 0.5);
            max-height: 300px;
            overflow-y: auto;
            word-wrap: break-word;
            white-space: pre-wrap;
        }

        footer {
            text-align: center;
            padding-top: 24px;
            border-top: 1px solid var(--color-border);
            color: var(--muted);
            font-size: 12px;
        }

        footer a {
            color: var(--color-accent);
            text-decoration: none;
        }

        footer a:hover {
            text-decoration: underline;
        }

        .hidden {
            display: none !important;
        }

        .section-divider {
            height: 1px;
            background-color: var(--color-border);
            margin: 32px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div>
                <h1>üîê Age Gated NFT Minter</h1>
                <p class="subtitle">Privacy-preserving age verification using Zama FHEVM</p>
            </div>
            <button id="btnConnect" class="btn">Connect</button>
        </header>

        <div class="grid">
            <!-- Step 1: Submit Age Verification -->
            <section class="card">
                <h3>
                    <span class="card-number">1</span>
                    Submit Encrypted Birth Year
                </h3>
                <p class="description">Provide your birth year (will be encrypted client-side by Relayer gateway)</p>

                <div>
                    <label for="birthYear">Birth year (e.g. 1990)</label>
                    <input id="birthYear" type="number" min="1900" max="2100" value="1990">
                </div>

                <div class="row">
                    <button id="btnSubmitAge" class="btn">Submit Age Verification</button>
                    <div id="ageStatus" class="status hidden"></div>
                </div>

                <div id="ageHandleBox" class="hidden">
                    <label>Verification Handle (bytes32)</label>
                    <pre id="ageHandleOutput">‚Äî</pre>
                </div>
            </section>

            <!-- Step 2: Make Public -->
            <section class="card">
                <h3>
                    <span class="card-number">2</span>
                    Make Verification Public
                </h3>
                <p class="description">Make your age verification result publicly decryptable by the oracle</p>

                <div class="row">
                    <button id="btnMakePublic" class="btn">Make Verification Public</button>
                    <div id="makePublicStatus" class="status hidden"></div>
                </div>

                <div>
                    <label for="verifyAddr">Address (optional)</label>
                    <input id="verifyAddr" type="text" placeholder="Leave empty for your address">
                </div>

                <button id="btnGetHandle" class="btn secondary">Get Verification Handle</button>

                <div id="handleResult" class="result hidden"></div>
            </section>

            <!-- Step 3: Decrypt & Mint -->
            <section class="card">
                <h3>
                    <span class="card-number">3</span>
                    Decrypt & Mint NFT
                </h3>
                <p class="description">Decrypt the verification and mint NFT if age is verified</p>

                <div class="row">
                    <button id="btnDecrypt" class="btn">Decrypt & Mint if Allowed</button>
                    <button id="btnOnlyDecrypt" class="btn secondary">Decrypt Only</button>
                    <div id="decryptStatus" class="status hidden"></div>
                </div>

                <div id="mintResult" class="result hidden"></div>
            </section>
        </div>

        <!-- Console Logs -->
        <section class="console-section">
            <h3>üìã Console Logs (Developer)</h3>
            <p class="description">All actions are logged here (same as browser DevTools)</p>
            <pre id="devLog">Ready ‚Äî performing actions will appear here...</pre>
        </section>

        <footer>
            Built with Zama FHEVM ¬∑ Relayer SDK 0.3.x
        </footer>
    </div>

  <script type="module">
  // Minimal, direct adaptation from your example logic
  import { initSDK, createInstance, SepoliaConfig } from "https://cdn.zama.org/relayer-sdk-js/0.3.0-5/relayer-sdk-js.js";
  import { BrowserProvider, Contract, getAddress } from "https://cdn.jsdelivr.net/npm/ethers@6.15.0/+esm";

  // CONFIG: use your contract address
  const CONFIG = {
    RELAYER_URL: "https://relayer.testnet.zama.org",
    GATEWAY_URL: "https://gateway.testnet.zama.org",
    CONTRACT_ADDRESS: "0xC59708C6296F5EC797189aA11Bf6e82285870C0F"
  };

  // ABI matching the AgeGatedNFT contract
  const ABI = [
    "function submitAgeVerification(bytes32,bytes) external returns (bytes32)",
    "function makeAgeVerificationPublic() external",
    "function mintNFT(bool) external returns (uint256)",
    "function getVerificationHandle(address) external view returns (bytes32)",
    "function hasVerification(address) external view returns (bool)",
    "function hasMintedAlready(address) external view returns (bool)"
  ];

  let provider, signer, address, contract, relayer;
  const $ = s => document.querySelector(s);
const logs = [];
        const maxLogs = 200;

        function log(...args) {
            const timestamp = new Date().toLocaleTimeString();
            const message = args.map(arg => {
                if (typeof arg === 'object') {
                    return JSON.stringify(arg, null, 2);
                }
                return String(arg);
            }).join(' ');

            const logEntry = `[${timestamp}] ${message}`;
            logs.push(logEntry);

            if (logs.length > maxLogs) {
                logs.shift();
            }

            updateDevLog();
            console.log(...args);
        }

        function updateDevLog() {
            const devLogEl = document.getElementById('devLog');
            devLogEl.textContent = logs.join('\n');
            devLogEl.scrollTop = devLogEl.scrollHeight;
        }

        function logStatus(type, message) {
            log(`[${type.toUpperCase()}] ${message}`);
        }

        // ============ UI UTILITIES ============
        function showStatus(elementId, type, message) {
            const el = document.getElementById(elementId);
            el.className = `status ${type}`;
            el.textContent = message;
            el.classList.remove('hidden');
        }

        function hideStatus(elementId) {
            document.getElementById(elementId).classList.add('hidden');
        }

        function showResult(elementId, title, value) {
            const el = document.getElementById(elementId);
            el.innerHTML = `
                <div class="result-label">${title}</div>
                <div class="result-value">${value}</div>
            `;
            el.classList.remove('hidden');
        }

        function hideResult(elementId) {
            document.getElementById(elementId).classList.add('hidden');
        }

  // Simple logger in UI + console


function devLog(...args) {
    const timestamp = new Date().toLocaleTimeString();
    const message = args.map(arg => {
        if (typeof arg === 'object') {
            return JSON.stringify(arg, null, 2);
        }
        return String(arg);
    }).join(' ');

    const logEntry = `[${timestamp}] ${message}`;
    logs.push(logEntry);

    if (logs.length > maxLogs) {
        logs.shift();
    }

    const pre = $("#devLog");
    pre.textContent = logs.join('\n');
    pre.scrollTop = pre.scrollHeight;
    console.log(...args);
}

  function setStatus(selector, text, kind='pending') {
    const el = $(selector);
    if (!el) return;
    el.style.display = 'inline-block';
    el.className = 'status ' + kind;
    el.textContent = text;
    devLog(`[STATUS ${selector}]`, text);
  }

  function clearStatus(selector) {
    const el = $(selector);
    if (!el) return;
    el.style.display = 'none';
  }

  // connect wallet + relayer
  async function connect() {
    try {
      devLog("connect: start");
      if (!window.ethereum) throw new Error("No wallet (window.ethereum) detected");
      provider = new BrowserProvider(window.ethereum);
      await provider.send("eth_requestAccounts", []);
      signer = await provider.getSigner();
      address = await signer.getAddress();
      devLog("connect: address", address);

      contract = new Contract(getAddress(CONFIG.CONTRACT_ADDRESS), ABI, signer);
      devLog("connect: contract instance", CONFIG.CONTRACT_ADDRESS);

      $("#btnConnect").textContent = address.slice(0,6) + "‚Ä¶" + address.slice(-4);

      if (!relayer) {
        devLog("connect: init relayer SDK");
        await initSDK();
        relayer = await createInstance({
          ...SepoliaConfig,
          relayerUrl: CONFIG.RELAYER_URL,
          gatewayUrl: CONFIG.GATEWAY_URL,
          network: window.ethereum,
          debug: true
        });
        devLog("connect: relayer instance ready");
      }

      // set default verify address input
      $("#verifyAddr").value = address;

      devLog("connect: done");
      return true;
    } catch (err) {
      console.error("Connect error:", err);
      setStatus("#ageStatus", "Wallet connect failed", "error");
      devLog("connect error", err.message || err);
      return false;
    }
  }

  $("#btnConnect").onclick = connect;

  // HELPER: convert Uint8Array -> hex
  function toHex(u8) {
    if (typeof u8 === 'string') return u8;
    if (u8 instanceof Uint8Array || Array.isArray(u8)) {
      return '0x' + Array.from(u8).map(b=>b.toString(16).padStart(2,'0')).join('');
    }
    return String(u8);
  }

  // CLEAN handle (remove any "Match Handle:" prefix etc)
  function cleanHandle(raw) {
    if (!raw) return raw;
    return String(raw).trim().split("\n").pop().trim();
  }

  // Submit encrypted birth year -> submitAgeVerification(externalHandle, attestation)
  $("#btnSubmitAge").onclick = async () => {
    try {
      devLog("submitAge: start");
      setStatus("#ageStatus", "Preparing...", "pending");

      if (!await connect()) return;

      const birthYear = parseInt($("#birthYear").value);
      if (!birthYear || birthYear < 1900 || birthYear > 2100) {
        throw new Error("Invalid birth year");
      }

      setStatus("#ageStatus", "Encrypting birth year (Relayer)...", "pending");
      devLog("submitAge: creating encrypted input", { contract: CONFIG.CONTRACT_ADDRESS, user: address });

      const enc = relayer.createEncryptedInput(getAddress(CONFIG.CONTRACT_ADDRESS), getAddress(address));
      enc.add16(BigInt(birthYear));

      const { handles, inputProof } = await enc.encrypt();
      devLog("submitAge: encryption result", { handles, inputProof });

      // handles[0] should be bytes32 or Uint8Array; convert to hex string
      const handleRaw = handles[0]?.handle || handles[0]?.ciphertext || handles[0];
      const handle = typeof handleRaw === 'string' ? handleRaw : toHex(handleRaw);

      const att = (typeof inputProof === 'string') ? (inputProof.startsWith('0x') ? inputProof : '0x' + inputProof) : toHex(inputProof);

      devLog("submitAge: extracted handle & attestation", { handle, att: att.slice(0,40) + '...' });

      setStatus("#ageStatus", "Submitting to chain...", "pending");
      const tx = await contract.submitAgeVerification(handle, att);
      devLog("submitAge: tx sent", tx.hash);
      const receipt = await tx.wait();
      devLog("submitAge: tx confirmed", { blockNumber: receipt.blockNumber, status: receipt.status });

      // The contract returns bytes32 handle as event emitted; but we also have direct handle we sent ‚Äî display that
      $("#ageHandleOutput").textContent = cleanHandle(handle);
      $("#ageHandleBox").style.display = 'block';

      setStatus("#ageStatus", "‚úÖ Age verification submitted", "success");
      devLog("submitAge: done");

    } catch (e) {
      console.error("submitAge error:", e);
      setStatus("#ageStatus", "‚ùå " + (e.message || e), "error");
      devLog("submitAge error", e.message || e);
    }
  };

  // Make public ‚Äî call makeAgeVerificationPublic()
  $("#btnMakePublic").onclick = async () => {
    try {
      devLog("makePublic: start");
      setStatus("#decryptStatus", "Making verification public...", "pending");
      if (!await connect()) return;

      // The contract requires the caller to have a stored verification (msg.sender). So user must call from their wallet
      const tx = await contract.makeAgeVerificationPublic();
      devLog("makePublic: tx sent", tx.hash);
      const receipt = await tx.wait();
      devLog("makePublic: confirmed", receipt);
      setStatus("#decryptStatus", "‚úÖ Verification is public (on-chain)", "success");
    } catch (e) {
      console.error("makePublic error:", e);
      setStatus("#decryptStatus", "‚ùå " + (e.message || e), "error");
      devLog("makePublic error", e.message || e);
    }
  };

  // Get handle for a given address via getVerificationHandle(address)
  $("#btnGetHandle").onclick = async () => {
    try {
      devLog("getHandle: start");
      if (!await connect()) return;
      const target = $("#verifyAddr").value || address;
      setStatus("#decryptStatus", "Fetching handle...", "pending");
      const handle = await contract.getVerificationHandle(target);
      devLog("getHandle: result", handle);
      $("#ageHandleOutput").textContent = cleanHandle(handle);
      $("#ageHandleBox").style.display = 'block';
      setStatus("#decryptStatus", "‚úÖ Handle retrieved", "success");
    } catch (e) {
      console.error("getHandle error:", e);
      setStatus("#decryptStatus", "‚ùå " + (e.message || e), "error");
      devLog("getHandle error", e.message || e);
    }
  };

  // PUBLIC DECRYPT helper (robust for SDK 0.3.x)
  async function publicDecryptHandle(handleRaw) {
    if (!relayer) throw new Error("Relayer not initialized");
    const handle = cleanHandle(handleRaw);
    if (!handle || !handle.startsWith("0x") || handle.length !== 66) {
      throw new Error("Invalid handle format (must be bytes32 hex)");
    }

    devLog("publicDecrypt: requesting decrypt for", handle);
    const req = [ handle ];
    devLog("publicDecrypt: request array", req);

    const out = await relayer.publicDecrypt(req);
    devLog("publicDecrypt: raw output", out);

    if (!out) throw new Error("Empty decrypt response");

    // If out.clearValues exists (new format), use it
    if (out.clearValues && typeof out.clearValues === 'object') {
      const lower = handle.toLowerCase();
      const v = out.clearValues[handle] ?? out.clearValues[lower];
      if (v === undefined) {
        throw new Error("Decrypt produced no value for this handle");
      }
      devLog("publicDecrypt: clear value (from clearValues)", v);
      return String(v);
    }

    // If response is an array or single-value
    if (Array.isArray(out)) {
      // common case: ["1"] or [{ value: "1" }]
      const first = out[0];
      const val = (typeof first === 'string') ? first : (first?.value ?? first?.result ?? null);
      if (val === null || val === undefined) throw new Error("Invalid decrypt array response");
      devLog("publicDecrypt: clear value (from array)", val);
      return String(val);
    }

    // fallback: try properties
    const maybe = out[handle] ?? out[handle.toLowerCase()] ?? out.value ?? out.result;
    if (maybe === undefined) throw new Error("Unrecognized decrypt response format");
    devLog("publicDecrypt: clear value (fallback)", maybe);
    return String(maybe);
  }

  // Decrypt & Mint if allowed (decrypt + call mintNFT(true))
  $("#btnDecrypt").onclick = async () => {
    try {
      devLog("decryptAndMint: start");
      setStatus("#decryptStatus", "Connecting...", "pending");
      if (!await connect()) return;

      // get handle: from displayed area or fetch by address
      let raw = $("#ageHandleOutput").textContent || '';
      raw = raw.trim();
      if (!raw || raw === '‚Äî') {
        // try fetch by address
        const target = $("#verifyAddr").value || address;
        devLog("decryptAndMint: no local handle; fetching for", target);
        setStatus("#decryptStatus", "Fetching handle for address...", "pending");
        const handle = await contract.getVerificationHandle(target);
        raw = cleanHandle(handle);
        $("#ageHandleOutput").textContent = raw;
        $("#ageHandleBox").style.display = 'block';
      } else {
        raw = cleanHandle(raw);
      }

      setStatus("#decryptStatus", "Requesting public decrypt...", "pending");
      const clear = await publicDecryptHandle(raw);

const allowed =
  clear === true ||
  clear === "true" ||
  clear === "1" ||
  clear === 1;

$("#mintResult").style.display = 'block';

if (allowed) {
  $("#mintResult").className = 'result ok';
  $("#mintResult").innerHTML = `<strong>‚úÖ Allowed</strong><div>Value: ${clear}</div>`;
  setStatus("#decryptStatus", "‚úÖ Decrypted: allowed", "success");
} else {
  $("#mintResult").className = 'result fail';
  $("#mintResult").innerHTML = `<strong>‚ùå Not allowed</strong><div>Value: ${clear}</div>`;
  setStatus("#decryptStatus", "‚ùå Decrypted: not allowed", "error");
}

      setStatus("#decryptStatus", "‚úÖ Decrypted allowed. Minting NFT...", "success");
      devLog("decryptAndMint: calling mintNFT(true)");

      const tx = await contract.mintNFT(true);
      devLog("decryptAndMint: mint tx sent", tx.hash);
      const receipt = await tx.wait();
      devLog("decryptAndMint: mint confirmed", receipt);

      // try to extract tokenId from events or receipt (many ERC721s emit Transfer)
      let tokenId = null;
      try {
        // search logs for Transfer event topics[0] is Transfer signature
        const transferTopic = "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef";
        for (const l of receipt.logs) {
          if (l.topics && l.topics[0] && l.topics[0].toLowerCase() === transferTopic) {
            // tokenId is topics[3] (indexed tokenId) when Transfer(address,address,uint256)
            const rawId = l.topics[3];
            if (rawId) {
              tokenId = BigInt(rawId).toString();
              break;
            }
          }
        }
      } catch (e) { devLog("tokenId extraction failed", e); }

      $("#mintResult").style.display = 'block';
      $("#mintResult").className = 'result ok';
      $("#mintResult").innerHTML = `<strong>‚úÖ NFT minted</strong><div style="margin-top:6px">Tx: <code>${tx.hash}</code>${tokenId?'<div>Token ID: '+tokenId+'</div>':''}</div>`;
      setStatus("#decryptStatus", "‚úÖ NFT minted", "success");
      devLog("decryptAndMint: done", { txHash: tx.hash, tokenId });

    } catch (e) {
      console.error("decryptAndMint error:", e);
      setStatus("#decryptStatus", "‚ùå " + (e.message || e), "error");
      devLog("decryptAndMint error", e.message || e);
    }
  };

  // Decrypt only (no mint)
  $("#btnOnlyDecrypt").onclick = async () => {
    try {
      devLog("onlyDecrypt: start");
      setStatus("#decryptStatus", "Connecting...", "pending");
      if (!await connect()) return;

      let raw = $("#ageHandleOutput").textContent || '';
      raw = cleanHandle(raw);
      if (!raw || raw === '‚Äî') {
        const target = $("#verifyAddr").value || address;
        const handle = await contract.getVerificationHandle(target);
        raw = cleanHandle(handle);
        $("#ageHandleOutput").textContent = raw;
        $("#ageHandleBox").style.display = 'block';
      }

      setStatus("#decryptStatus", "Decrypting...", "pending");
      const clear = await publicDecryptHandle(raw);
devLog("decryptAndMint: clear value", clear);

// NEW FORMAT SUPPORT
const allowed =
  clear === true ||
  clear === "true" ||
  clear === "1" ||
  clear === 1;

if (!allowed) {
  setStatus("#decryptStatus", "‚ùå Age verification failed (not allowed)", "error");
  $("#mintResult").style.display = 'block';
  $("#mintResult").className = 'result fail';
  $("#mintResult").innerHTML =
    `<strong>Not allowed:</strong> age check returned false`;
  return;
}

      $("#mintResult").style.display = 'block';
      if (allowed) {
        $("#mintResult").className = 'result ok';
        $("#mintResult").innerHTML = `<strong>‚úÖ Allowed</strong><div>Value: ${clear}</div>`;
        setStatus("#decryptStatus", "‚úÖ Decrypted: allowed", "success");
      } else {
        $("#mintResult").className = 'result fail';
        $("#mintResult").innerHTML = `<strong>‚ùå Not allowed</strong><div>Value: ${clear}</div>`;
        setStatus("#decryptStatus", "‚ùå Decrypted: not allowed", "error");
      }
      devLog("onlyDecrypt: done", { clear });

    } catch (e) {
      console.error("onlyDecrypt error:", e);
      setStatus("#decryptStatus", "‚ùå " + (e.message || e), "error");
      devLog("onlyDecrypt error", e.message || e);
    }
  };

  </script>
</body>
</html>
